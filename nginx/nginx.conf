worker_processes 1;

events {
    worker_connections 1024;
}

http {
    lua_shared_dict req_counter 10m;

    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=1g inactive=60m use_temp_path=off;

    # Proxy cache key without manually forcing the GET method
    proxy_cache_key "$scheme$request_method$host$request_uri";

    server {
        listen 8080;
        server_name localhost;

        location / {
            proxy_pass http://node-app:3000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        location ~* \.(jpg|jpeg|png|gif)$ {
            proxy_cache my_cache;
            proxy_cache_valid 200 1d;  # Cache duration is 1 day
            add_header X-Proxy-Cache $upstream_cache_status;
            add_header X-Cache-BYPASS-Reason $cache_bypass;

            # Ensure cache headers don't block the caching
            proxy_hide_header Cache-Control;
            proxy_hide_header Pragma;

            # Add Cache-Control header explicitly
            add_header Cache-Control "public, max-age=86400";

            # Ignore Cache-Control and Expires headers from upstream
            proxy_ignore_headers Cache-Control Expires;

            set $cache_bypass 1;

            access_by_lua_block {
                local cache_key = ngx.var.scheme .. "GET" .. ngx.var.host .. ngx.var.request_uri;
                local req_count = ngx.shared.req_counter:get(cache_key);

                -- Log the cache key during caching
                ngx.log(ngx.ERR, "[Caching] Cache key: ", cache_key, ", Request count: ", req_count or "nil");

                if req_count and req_count >= 2 then
                    ngx.var.cache_bypass = 0;  -- Allow caching after 2 requests
                    ngx.log(ngx.ERR, "[Caching] Cache enabled for key: ", cache_key);
                else
                    if req_count then
                        ngx.shared.req_counter:incr(cache_key, 1);
                        ngx.log(ngx.ERR, "[Caching] Request count incremented for key: ", cache_key, ", New count: ", req_count + 1);
                    else
                        ngx.shared.req_counter:set(cache_key, 1, 60);  -- Set request count to 1 with a TTL of 60 seconds
                        ngx.log(ngx.ERR, "[Caching] Initialized request count for key: ", cache_key);
                    end
                    ngx.var.cache_bypass = 1;
                end
            }

            proxy_cache_bypass $cache_bypass;
            proxy_no_cache $cache_bypass;

            proxy_pass http://node-app:3000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        location /purge {
            allow all;  # Allow for testing; restrict in production

            content_by_lua_block {
                local uri = ngx.var.arg_uri;
                if not uri then
                    ngx.say("Error: missing uri parameter");
                    return;
                end

                -- Rebuild the cache key for purging
                local cache_key = ngx.var.scheme .. "GET" .. ngx.var.host .. uri;
                ngx.log(ngx.ERR, "[Purging] Cache key for purge: ", cache_key);

                local cache_zone = ngx.shared.req_counter;  -- Memory cache zone

                -- Remove from memory cache
                local memory_purge_result = cache_zone:delete(cache_key);
                if memory_purge_result then
                    ngx.log(ngx.ERR, "[Purging] Memory cache purged for: " .. uri);
                else
                    ngx.log(ngx.ERR, "[Purging] Failed to purge memory cache for: " .. uri);
                end

                -- Disk cache removal based on cache_path and levels
                local cache_path = "/var/cache/nginx";  -- Nginx cache directory
                local cache_file = ngx.md5(cache_key);  -- Hash the cache key

                -- Construct the cache file path based on the Nginx cache levels (1:2)
                local cache_dir1 = cache_file:sub(1, 1);  -- First-level directory
                local cache_dir2 = cache_file:sub(2, 3);  -- Second-level directory
                local cache_file_path = cache_path .. "/" .. cache_dir1 .. "/" .. cache_dir2 .. "/" .. cache_file;

                ngx.log(ngx.ERR, "[Purging] Attempting to delete disk cache at path: " .. cache_file_path);

                -- Check if the file exists before attempting to delete it
                local file_exists = io.open(cache_file_path, "r");

                if file_exists then
                    file_exists:close();  -- Close before attempting to remove
                    local disk_purge_result = os.remove(cache_file_path);

                    if disk_purge_result then
                        ngx.log(ngx.ERR, "[Purging] Disk cache purged for: " .. uri);
                    else
                        ngx.log(ngx.ERR, "[Purging] Failed to purge disk cache for: " .. uri .. " at path: " .. cache_file_path);
                    end
                else
                    ngx.log(ngx.ERR, "[Purging] Cache file not found for purging at: " .. cache_file_path);
                end

                ngx.say("Cache purged for " .. uri);
            }
        }
    }
}
